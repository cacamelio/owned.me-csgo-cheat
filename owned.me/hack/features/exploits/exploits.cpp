#include "../features.hpp"

void c_tick_base::store(int tickbase, int cmd, int shift, bool restore, int cmd_diff)
{
	this->data.tickbase = tickbase;
	this->data.command_number = cmd;
	this->data.shift_amount = shift;
	this->data.restore_tickbase = restore;
	this->data.cmd_diff = cmd_diff;
}

void c_tick_base::fix(int new_command_number, int& tickbase)
{
	auto d = this->data;
	if (d.command_number <= 0)
		return;

}

c_tick_base tick_base = {};

exploit_vars_t exploit[2] = {};

namespace exploits
{
	const int DT_SHIFT = 13;
	const int HS_SHIFT = 9;

	int shift_amount = 0;
	int shift_timer = 0;
	int charge_ticks = 0;
	int simulation_ticks = 0;
	int MaxChoke = 16;

	bool need_to_recharge = false;
	bool recharge_completed = false;

	__forceinline void reset()
	{
		shift_amount = 0;
		shift_timer = 0;
		charge_ticks = 0;
	}

	void shift_cmd(UserCmd* cmd, int amount)
	{
		int cmd_number = cmd->command_number;
		auto new_cmd = &interfaces::input->m_pCommands[ ( cmd->command_number + 1 ) % MULTIPLAYER_BACKUP ];

		auto net_chan = interfaces::clientstate->net_channel;
		if (!new_cmd || !net_chan)
			return;

		std::memcpy(new_cmd, cmd, sizeof(UserCmd));

		new_cmd->command_number++;
		new_cmd->buttons &= ~( IN_ATTACK | IN_ATTACK2 );

		movement::FixMove(new_cmd, g::vStrafeAngles);

		for (int i = 0; i < amount; ++i)
		{
			int cmd_num = new_cmd->command_number + i;

			auto cmd_ = interfaces::input->get_pUser_cmd(cmd_num);
			auto verifided_cmd = interfaces::input->get_pUser_verifCmd(cmd_num);

			std::memcpy(cmd_, new_cmd, sizeof(UserCmd));

			cmd_->command_number = cmd_num;
			cmd_->predicted = cmd_->tick_count == INT_MAX;

			std::memcpy(verifided_cmd, cmd_, sizeof(UserCmd));
			verifided_cmd->crc = cmd_->get_check_sum();

			++interfaces::clientstate->choked_commands;
			++net_chan->m_nChokedPackets;
			++net_chan->m_nOutSequenceNr;
		}
	}

	void double_tap()
	{
		exploit[ dt ].enabled = true;
		if (exploit[dt].recharge && fabs( interfaces::globals->realtime - exploit[ dt ].flTime ) > 0.4f && exploit[ dt ].flTime > 0.0f )
		{
			exploit[ dt ].flTime = 0.0f;
			exploit[dt].recharge = false;
			exploit[dt].recharging = true;
			reset();
			return;
		}

		if (exploit[dt].recharging)
		{
			shift_timer = 0;
			if (aimbot::can_shoot(DT_SHIFT))
			{
				exploit[dt].recharging = false;
				exploit[dt].prepare = true;
				exploit[dt].bullets = 0;
			}
			else if (g::pCmd->buttons & IN_ATTACK)
				exploit[dt].bullets++;
		}

		if (!config.enable_antiaim)
		{
			exploit[dt].enabled = false;
			exploit[dt].prepare = false;
			reset();
			return;
		}

		if (!g_keyhandler.CheckKey(config.doubletap_key, config.doubletap_key_style) || g::bFakeDuck)
		{
			exploit[dt].enabled = false;
			exploit[dt].prepare = false;

			if (!g_keyhandler.CheckKey(config.hideshot_key, config.hideshot_key_style))
			{
				if (exploit[dt].works)
				{
					shift_cmd(g::pCmd, DT_SHIFT + 2);
					exploit[dt].recharge = true;
					exploit[dt].works = false;
				}
			}

			return;
		}

		if (!exploit[dt].prepare
			|| g::pLocalPlayer->HasGunGameImmunity()
			|| g::pLocalPlayer->Flags() & FL_FROZEN)
		{
			exploit[dt].enabled = false;
			if (exploit[dt].bullets == 0 && exploit[dt].works)
			{
				shift_cmd(g::pCmd, DT_SHIFT + 2);
				exploit[dt].recharge = true;
				exploit[dt].works = false;
			}
			reset();
			return;
		}

		exploit[dt].works = true;

		bool can_dt = g::pLocalWeapon->IsGun() && g::pLocalWeapon->ItemDefinitionIndex() != WEAPON_REVOLVER;
		bool is_firing = g::pCmd->buttons & IN_ATTACK && aimbot::can_shoot();

		if (recharge_completed)
		{
			if (!g::pLocalWeapon)
				return;

			if (can_dt && is_firing)
			{
				shift_cmd(g::pCmd, DT_SHIFT);

				exploit[ dt ].flTime = interfaces::globals->realtime;

				exploit[dt].enabled = false;
				exploit[dt].prepare = false;
				exploit[ dt ].recharge = true;
				recharge_completed = false;

				exploit[dt].bullets++;

				*g::bSendPacket = true;
			}
			else if (g::pLocalWeapon->ItemDefinitionIndex() != WEAPON_REVOLVER)
			{
				shift_amount = DT_SHIFT;
			}
			else
				shift_amount = shift_timer = 0;
		}
	}

	void hide_shots()
	{
		exploit[hs].shot = false;
		exploit[hs].enabled = true;

		if (!config.enable_antiaim || g_keyhandler.CheckKey(config.doubletap_key, config.doubletap_key_style))
		{
			exploit[hs].enabled = false;
			exploit[hs].prepare = false;
			exploit[hs].works = false;
			return;
		}

		if (!g_keyhandler.CheckKey(config.hideshot_key, config.hideshot_key_style) || g::bFakeDuck)
		{
			exploit[hs].enabled = false;
			exploit[hs].prepare = false;

			if (exploit[hs].works)
			{
				shift_cmd(g::pCmd, DT_SHIFT + 2);
				exploit[hs].works = false;
			}

			reset();
			return;
		}

		if (g::pLocalPlayer->HasGunGameImmunity()
			|| g::pLocalPlayer->Flags() & FL_FROZEN)
		{
			exploit[hs].enabled = false;
			reset();
			return;
		}

		exploit[hs].works = true;

		if (g::pLocalWeapon->IsGun() && g::pLocalWeapon->ItemDefinitionIndex() != WEAPON_REVOLVER)
		{
			if (aimbot::can_shoot(HS_SHIFT))
			{
				if ( g::pCmd->buttons & IN_ATTACK )
				{
					shift_amount = HS_SHIFT;
					if ( shift_amount > 0 )
						tick_base.store( g::pLocalPlayer->GetTickBase( ), g::pCmd->command_number, simulation_ticks, true );

					*g::bSendPacket = true;
					exploit[ hs ].shot = true;
				}
			}
			else
				g::pCmd->buttons &= ~IN_ATTACK;
		}
	}

	void prepare()
	{
		auto exp_callback = [&](bool bind_a,bool bind_b, int key_num1, int key_num2, int idx, int idx2)
		{
			if (bind_a)
			{
				if (!exploit[idx].toggle)
				{
					exploit[idx].prepare = true;
					exploit[idx].toggle = true;
				}
			}
			else
				exploit[idx].toggle = false;

			if (exploit[idx].prepare && key_num1 != key_num2)
				exploit[idx2].prepare = false;
		};

		auto hs_active = g_keyhandler.CheckKey(config.hideshot_key, config.hideshot_key_style);
		auto dt_active = g_keyhandler.CheckKey(config.doubletap_key, config.doubletap_key_style);

		exp_callback(dt_active, hs_active, config.doubletap_key, config.hideshot_key, dt, hs);
		exp_callback(hs_active, dt_active, config.hideshot_key, config.doubletap_key, dt, hs);

		bool ready = exploit[dt].enabled && exploit[dt].prepare || exploit[hs].enabled && exploit[hs].prepare;
		if (charge_ticks < 17 && ready)
		{
			need_to_recharge = true;
			recharge_completed = false;
		}
	}

	bool enabled()
	{
		return ((g_keyhandler.CheckKey(config.doubletap_key, config.doubletap_key_style) || g_keyhandler.CheckKey(config.hideshot_key, config.hideshot_key_style)) && exploits::charge_ticks >= 16) && !exploits::need_to_recharge;
	}

	void run()
	{
		double_tap();
		hide_shots();
	}
}